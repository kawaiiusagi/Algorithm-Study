# 2217 로프
[백준 2217번 로프](https://www.acmicpc.net/problem/2217)

### 문제 요약
여러 개의 로프가 주어질 때, 각 로프가 견딜 수 있는 중량을 기준으로 일부 로프를 선택해 들 수 있는 최대 중량을 구하는 문제이다.

### 코드
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	int n;
	cin >> n;

	vector<int> kg;

	for (int i = 0; i < n; i++) {
		int x;
		cin >> x;
		kg.push_back(x);
	}
	for (int i = 1; i < n; i++) {
		int key = kg[i];
		int j = i - 1;

		while (j >= 0 && kg[j] > key) {
			kg[j + 1] = kg[j];
			j--;
		}
		kg[j + 1] = key;
	}
	int ans = 0;
	for (int i = 0; i < n; i++) {
		int cur = kg[i] * (n - i);

		if (ans < cur) {
			ans = cur;
		}
	}

	cout << ans;

	return 0;
}
```
- 문제를 처음 접했을 때 조건을 정확히 이해하지 못해 오류를 찾는 데 시간이 소요되었다. 이를 통해 **문제를 충분히 분석한 뒤
구현에 들어가는 과정의 중요성**을 느꼈다.
- 최대 중량을 구하는 과정에서 알고리즘적 사고가 쉽지 않았으나, 로프 여러 개를 사용할 경우 전체가 버틸 수 있는 중량은
**선택된 로프 중 최소 중량에 의해 결정된다**는 점을 기준으로 사고를 전환하며 해결할 수 있었다.
- 구현 과정에서 벡터 사용 시 동일한 실수를 반복한 점이 아쉬웠으며, 벡터는 크기를 먼저 할당하지 않은 상태에서는
인덱스를 통한 접근이 불가능하다는 점을 다시 한 번 인식하게 되었다.

### 내가 생각했을 때 이 문제에서 중요한 점
- **최댓값을 구하는 알고리즘의 구현**
  -> 여러 로프를 사용할 때 들 수 있는 최대 중량은, 각 로프의 최대 중량을 정렬한 뒤 가장 약한 로프를 기준으로
  `해당 로프 * 사용 개수`를 계산하여 결정한다
- 벡터를 사용할 경우, 크기를 미리 할당하지 않았다면 `push_back` 등을 통해 원소를 추가해야 하며, **존재하지 않는
인덱스에 바로 접근해서는 안 된다는 점**을 기억해야만 한다.

### 내가 생각하는 이 문제에서 중요한 점
- 최댓값을 구하는 알고리즘의 구현
    => 만일 각 로프의 최대 중량 중에서 버틸 수 있는 중량은 최대 중량이 가작 작은 로프를 기준으로 생각해봐야 한다.
    또한 로프의 최대 중량이 작으면, 그 안에서의 최댓값은 당연히 n개에서 그 요소를 뺀 값이 된다.
- 만일 처음에 벡터의 크기를 할당하지 않았을 경우, 바로 원소에 접근하는 것이 불가능하다는 것을 기억하자.
