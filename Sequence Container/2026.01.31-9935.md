# 9935 문자열 폭발
[백준 9935번 문자열 폭발](https://www.acmicpc.net/problem/9935)

### 문제 요약
문자열을 왼쪽부터 하나씩 처리하면서, 특정 문자열(폭탄)이 생성되는 순간 즉시 제거하는 문제이다.

### 코드
```cpp
#include <iostream>
using namespace std;

int main()
{
    string first, bomb;
    cin >> first >> bomb;

    string real;

    for (int i = 0; i < first.size(); i++) {
        real.push_back(first[i]);

        if (real.size() >= bomb.size() && real.back() == bomb.back()) {
            bool isBomb = true;

            for (int j = 0; j < bomb.size(); j++) {
                if (real[real.size() - bomb.size() + j] != bomb[j]) {
                    isBomb = false;
                    break;
                }
            }

            if (isBomb) {
                for (int j = 0; j < bomb.size(); j++) {
                    real.pop_back();
                }
            }
        }
    }

    if (real.empty()) {
        cout << "FRULA";
    }
    else {
        cout << real;
    }

    return 0;
}
```

---
- 이번 문제는 지금까지 풀었던 문제들 중 가장 오래 걸렸고, 체감 난이도 또한 가장 높았다. 특히 과거에 풀었던 괄호 유형 문제와 유사하다고 느껴 그 사고방식에 계속 매달리게 되었고, 그 틀에서 벗어나는 데 시간이 오래 걸렸다.
- 그 결과 “직전 상태만 검사하면 된다”는 사고에 강하게 묶여 입력 문자열을 기준으로 앞뒤 문자를 계속 비교하며 인덱스를 계산하려 했고, 이 과정에서 음수 인덱스, 범위 초과, 과도한 조건 분기 등으로 구현이 복잡해졌다.
- 그러나 이 문제의 핵심은 **뒤의 한 글자를 검사하는 것이 아니라, 뒤의 ‘구간’을 검사하는 것**이라는 점이었다.
- 이 문제에서는 입력 문자열을 직접 수정하거나 검사하는 방식이 아니라, **결과 문자열을 하나 만들어가며 그 끝 부분만을 지속적으로 확인하는 방식**으로 접근해야 했다.
  1. 문자를 하나씩 결과 문자열에 추가한다.
  2. 추가 직후, 결과 문자열의 끝에서 `bomb.length()`만큼의 구간이 폭탄 문자열과 같은지 확인한다.
  3. 같다면 해당 구간을 즉시 제거한다.
  4. 위 과정을 문자열 끝까지 반복한다.
- 이와 같이 사고의 기준을 “입력 상태”가 아닌 “현재 결과 상태”로 전환한 이후에야 문제를 안정적으로 해결할 수 있었다.

### 이 문제에서 중요한 점
- 알고리즘 구상과 구현  
  → *어디를 검사할 것인가*보다 **언제 조건이 확정되는지를 먼저 생각하는 사고**
- 결과 상태를 기준으로 문제를 바라보는 접근 방식
