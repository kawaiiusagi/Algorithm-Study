# 2659 십자카드 문제
[백준 2659번 십자카드 문제](https://www.acmicpc.net/problem/2659)

### 문제 요약
네 자리 숫자가 주어질 때, 숫자를 원형으로 회전하며 만들 수 있는 네 가지 수 중 **가장 작은 수(시계수)**를 구하고, 1111부터 해당 시계수까지 등장하는 서로 다른 시계수의 개수를 계산하는 문제이다.

### 코드
```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int getClockNumber(int a, int b, int c, int d) {
    int n1 = a*1000 + b*100 + c*10 + d;
    int n2 = b*1000 + c*100 + d*10 + a;
    int n3 = c*1000 + d*100 + a*10 + b;
    int n4 = d*1000 + a*100 + b*10 + c;

    return min(min(n1, n2), min(n3, n4));
}

int main() {
    int a, b, c, d;
    cin >> a >> b >> c >> d;

    int target = getClockNumber(a, b, c, d);

    int count = 0;

    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= 9; j++) {
            for (int k = 1; k <= 9; k++) {
                for (int l = 1; l <= 9; l++) {

                    int num = i*1000 + j*100 + k*10 + l;
                    int clockNum = getClockNumber(i, j, k, l);

                    if (num == clockNum) {

                        if (clockNum < target) {
                            count++;
                        }
                    }
                }
            }
        }
    }

    cout << count + 1 << endl;

    return 0;
}
---
```
### 풀이 과정 및 느낀 점
- 처음에는 1111부터 9999까지의 수를 전부 벡터에 저장한 뒤, 각 수를 회전시켜 비교하는 방식으로 접근하려 했다.
- 특히 “연속적으로 더하면 결국 모든 수를 돌게 되지 않나?”라는 사고에 묶여 있었는데, 이 문제의 핵심은 **모든 수를 도는 것이 아니라, 각 수의 ‘시계수’를 구하는 것**이라는 점을 뒤늦게 깨달았다.
- 또한 중복 제거를 위해 `set`을 사용하지 않고 구현하려다 보니, 어떤 값을 기준으로 저장해야 하는지에 대한 사고가 부족했다.
- 계산된 모든 경우를 저장하려는 방식은 비효율적이었고, 대신 **각 숫자에서 시계수를 바로 구해 그 값만을 기준으로 판단하는 구조**로 바꾸면서 해결 방향이 명확해졌다.
- 이 문제를 통해 단순 나열이나 반복보다, **기준이 되는 값을 먼저 정의하고 그 기준으로 정리하는 사고가 중요하다**는 점을 배웠다.

### 이 문제에서 중요한 점
- 숫자를 원형 구조로 바라보는 사고
- 모든 경우를 저장하려 하지 말고, 핵심 값(시계수)을 기준으로 정리하는 알고리즘 설계
- 구현 전에 기준과 비교 대상을 명확히 정의하는 문제 해석 능력
