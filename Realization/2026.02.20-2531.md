# 백준 2531 회전 초밥

## 문제 요약

회전 초밥 벨트 위에 N개의 접시가 원형으로 놓여 있다.  
연속된 k개의 접시를 선택했을 때, 서로 다른 초밥의 최대 종류 수를 구하는 문제이다.

추가로 쿠폰 번호 c번 초밥을 하나 더 받을 수 있으며,  
현재 선택한 구간에 c번 초밥이 없다면 +1이 가능하다.

출력은 가능한 최대 가지수 하나이다.

## 처음에 했던 착각

처음에는 다음과 같이 생각했다.

- 경우의 수를 전부 저장해야 하나?
- 중복 초밥이 있으면 그 구간은 버려야 하나?
- 서로 다른 경우만 따로 모아서 비교해야 하나?

그래서 `find()`로 중복을 검사하고,  
중복이 나오면 `clear()` 하는 방식으로 구현하려고 했다.

하지만 이 문제는 경우를 저장하는 문제가 아니라  
**현재 구간의 서로 다른 초밥 종류 수만 세는 문제**였다.

중복 초밥이 있다고 해서 구간이 무효가 되는 것이 아니라,  
단지 가지수가 증가하지 않을 뿐이라는 점을 깨달았다.

## 핵심 아이디어

이 문제의 본질은

> 슬라이딩 윈도우 + 빈도 배열 관리

이다.

- `cnt[x]` : 현재 구간에 x번 초밥이 몇 개 있는지
- `kind` : 현재 구간의 서로 다른 초밥 종류 수

중복을 제거하는 것이 아니라,  
처음 등장할 때만 `kind++`,  
완전히 사라질 때만 `kind--` 하는 방식으로 관리한다.

---

## 코드

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n, d, k, c;
    cin >> n >> d >> k >> c;

    vector<int> temp;

    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        temp.push_back(x);
    }

    for (int i = 0; i < k - 1; i++) {
        temp.push_back(temp[i]);
    }

    vector<int> cnt(d + 1, 0);
    int kind = 0;
    int ans = 0;

    for (int i = 0; i < k; i++) {
        if (cnt[temp[i]] == 0)
            kind++;
        cnt[temp[i]]++;
    }

    if (cnt[c] == 0)
        ans = kind + 1;
    else
        ans = kind;

    for (int i = 1; i < n; i++) {

        cnt[temp[i - 1]]--;
        if (cnt[temp[i - 1]] == 0)
            kind--;

        if (cnt[temp[i + k - 1]] == 0)
            kind++;
        cnt[temp[i + k - 1]]++;

        int total;
        if (cnt[c] == 0)
            total = kind + 1;
        else
            total = kind;

        if (total > ans)
            ans = total;
    }

    cout << ans;

    return 0;
}
```
---
## 풀이 과정

- 처음에는 경우의 수를 저장해야 하는 줄 알고 구조를 복잡하게 만들었다.
- 하지만 실제로는 최대값 하나만 구하면 되는 문제였다.
- 중복 초밥이 있으면 구간이 무효가 되는 것이 아니라, 종류 수만 증가하지 않을 뿐이었다.
- 슬라이딩 윈도우를 사용하여 매번 전체를 다시 세지 않고,  
  빠지는 초밥과 들어오는 초밥만 관리하도록 구현하였다.

---

## 핵심 포인트

- 경우의 수를 저장할 필요 없음
- 중복이 있어도 구간은 유효함
- 처음 등장할 때만 kind++
- 완전히 사라질 때만 kind--
- 쿠폰 초밥이 현재 구간에 없을 때만 +1
- 최대값만 추적하면 되는 문제

## 느낀 점

처음에는 경우를 전부 나열해야 한다고 착각하여  
문제를 과하게 복잡하게 만들었다.

하지만 실제로는 슬라이딩 윈도우를 이해하면  
구조가 매우 단순한 문제였다.

이 문제를 통해  
“중복 제거 사고”에서 “빈도 관리 사고”로 전환하는 것이  
중요하다는 것을 배웠다.
