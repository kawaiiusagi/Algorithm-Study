# 4949 균형잡힌 세상
[백준 4949번 균형잡힌 세상](https://www.acmicpc.net/problem/4949)

### 문제 요약
문자열이 주어질 때, 소괄호와 대괄호가 올바르게 짝을 이루고 중첩되어 있는지 스택을 이용해 판단하여, 
균형 잡혀 있으면 yes, 아니면 no를 출력하는 문제이다.

### 코드
```cpp
#include <iostream>
#include <stack>
#include <string>

using namespace std;

int main()
{
    string line;

    while (true) {
        getline(cin, line);

        if (line == ".") break;

        stack<char> st;
        bool invalid = false;

        for (char c : line) {
            if (c == '(' || c == '[') {
                st.push(c);
            }
            else if (c == ')') {
                if (!st.empty() && st.top() == '(') st.pop();
                else { invalid = true; break; }
            }
            else if (c == ']') {
                if (!st.empty() && st.top() == '[') st.pop();
                else { invalid = true; break; }
            }
        }

        if (!invalid && st.empty()) cout << "yes\n";
        else cout << "no\n";
    }

    return 0;
}
```

### 풀이 과정 및 느낀 점

이번 문제에서 가장 어려웠던 부분은 알고리즘 자체보다 **입력 처리와 종료·출력의 마무리 구조**였다.  
스택을 이용한 괄호 판별 로직은 비교적 빠르게 떠올렸지만, 입력 단위와 출력 타이밍을 정확히 잡지 못해 여러 번 오답과 출력 초과를 겪었다.

- 처음에는 이 문제를 문자 단위 처리 문제로 잘못 인식해 `cin >> char` 방식으로 접근했으나, 실제로는 **문장(한 줄) 단위로 판정하고 출력하는 문제**였다.  
  이 차이를 초반에 인식하지 못해 종료 조건(`"."`)과 출력 조건이 꼬였다.
- 이후 `getline`을 사용해 한 줄 전체를 입력받도록 구조를 수정하면서 문제 흐름이 자연스러워졌다.
- 구현 과정에서 여러 상태 변수(`stack`, `invalid` 등)를 사용했는데, **현재 문장에 대한 상태와 이전 입력을 기억하는 상태를 구분하지 못한 점**이 혼란의 원인이었다.
- 특히 `break`와 `continue`의 동작 범위를 정확히 추적하지 못해:
  - 종료 입력에서 출력이 발생하거나
  - 출력이 여러 번 발생하는 문제가 반복되었다.
- 이 문제를 통해 출력은 반드시 **문장 하나당 정확히 한 번**, 그리고 **모든 판정이 끝난 뒤에만** 하도록 구조를 고정해야 한다는 점을 명확히 인식하게 되었다.

---

### 이 문제를 통해 느낀 점

- 아이디어와 중간 로직이 맞더라도, **종료 조건과 출력 구조를 먼저 설계하지 않으면** 쉽게 오답으로 이어질 수 있다.
- 스택 문제에서는 자료구조 자체보다도, **입력 단위·상태 초기화·출력 타이밍을 포함한 전체 흐름 설계**가 중요하다는 것을 느꼈다.

---

### 체크리스트 (앞으로의 다짐)

- 종료 입력은 출력 대상인가?
- 출력은 테스트케이스당 정확히 1번만 발생하는가?
- 이 `break`는 어느 반복문을 탈출하는가?
- 상태 변수는 다음 입력 전에 초기화되는가?

---

### Key Points
- 스택을 이용한 괄호 상태 관리
- 입력 단위(문장 기준)에 대한 정확한 인식
- 종료 조건과 출력 타이밍을 포함한 코드 마무리 구조 설계
