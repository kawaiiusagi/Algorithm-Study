# 12605 단어순서 뒤집기
[백준 12605 단어순서 뒤집기](https://www.acmicpc.net/problem/12605)

### 문제 요약
여러 문장이 주어질 때, 각 문장에서 단어의 순서를 거꾸로 바꾸어 Case #x: 형식으로 출력하는 문제이다.

### 코드
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stack>

using namespace std;

int main()
{
	int n;
	cin >> n;
	cin.ignore();

	vector<string> q(n);

	for (int i = 0; i < n; i++) {
		getline(cin, q[i]);
	}

	for (int j = 0; j < n; j++) {
		stack<string> s;

		string word = "";

		for (char c : q[j]) {
			if (c == ' ') {
				if (!word.empty()) {
					s.push(word);
					word = "";
				}
			}
			else {
				word += c;
			}
		}
		if (!word.empty()) {
			s.push(word);
		}

		cout << "Case #" << j + 1 << ": ";

		while (!s.empty()) {
			cout << s.top() << " ";
			s.pop();
		}
		cout << endl;
	}

	return 0;
}
```
-처음에는 이 문제를 벡터만을 활용해 해결하려 했으나, 단어의 순서를 뒤집는 구조가 **FILO(First in, Last Out)**
특성과 일치한다는 점을 인식하고 스택을 사용하는 방향으로 접근을 전환하였다.
- 스택을 이용해 문제를 해결하는 과정에서도 어려움이 있었는데, 문자열을 순회하여 **단어 단위로 분리한 뒤
이를 스택에 저장하는 알고리즘**을 명확하게 구상하지 못해 코드를 짜는데에 상당한 시간이 소요되었다.
- 이 과정에서 조건식을 간겨랗게 표현할 수 있는 `!` 연산자의 활용법을 새롭게 이해하게 되었다.
- 또한 스택에 저장된 내용을 출력할 때 `for` 반복문을 사용하면 `pop()` 연산으로 인해 스택의 크기가 변하면서
오류가 발생할 수 있다는 점을 경험하였고, 이를 `while` 반복문을 사용하는 방식으로 개선하였다.
- 코드 완성 후 정상적으로 작동하지 않았던 원인은, 처음에 정수 `n`을 입력받은 뒤 `cin`버퍼에 남아있던 개행 문자
(`\n`)가 바로 다음 `getline` 입력에 영향을 주었기 때문이었다. 이를 해결하기 위해 `cin.ignore()`의 필요성을
정확히 이해하게 되었으며, 이후 입력 처리에서 반드시 이를 고려해야겠다고 느꼈다.

### 내가 생각하는 이 문제에서 중요한 포인트
- **스택의 FILO 구조를 문제 상황에 맞게 적용하는 사고**
- 문자열에서 **단어만을 정확히 분리하여 저장하는 알고리즘 설계**
