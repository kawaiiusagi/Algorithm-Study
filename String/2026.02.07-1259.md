# 백준 1259 팰린드롬수

### 문제 요약
정수가 문자열 형태로 주어질 때, 해당 수가 앞에서 읽으나 뒤에서 읽으나 같은 **팰린드롬 수인지**를 판단하는 문제이다.  
입력은 `0`이 들어오면 종료된다.

### 코드
```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    while (true) {
        string s;
        cin >> s;

        if (s == "0") break;

        bool isPalindrome = true;
        int len = s.length();

        for (int i = 0; i < len / 2; i++) {
            if (s[i] != s[len - 1 - i]) {
                isPalindrome = false;
                break;
            }
        }

        if (isPalindrome) cout << "yes\n";
        else cout << "no\n";
    }

    return 0;
}
```

---

### 풀이 과정 및 느낀 점
- 이 문제는 숫자의 크기가 크지 않기 때문에, 정수 연산보다는 **문자열로 처리하는 것이 훨씬 간단하다고 판단했다**.
- 처음에는 정수를 뒤집는 방식으로 접근하려 했지만, 문자열의 앞과 뒤를 비교하는 방식이 더 직관적이라고 느껴 문자열 풀이로 방향을 정했다.
- 문자열의 길이만큼 반복하면서, 앞쪽 인덱스와 뒤쪽 인덱스를 동시에 비교하면 쉽게 팰린드롬 여부를 판단할 수 있었다.
- 중간에 하나라도 다른 문자가 나오면 바로 `no`를 출력하도록 하여 불필요한 비교를 줄였다.
- 입력의 종료 조건이 `"0"`이라는 점을 놓치지 않고, **출력하지 않고 반복문을 종료해야 한다는 점**을 주의했다.


### 이 문제에서 중요한 점
- 숫자를 문자열로 변환하여 처리하는 사고
- 문자열의 앞과 뒤를 인덱스로 동시에 비교하는 방식
- 종료 조건(`0`)과 출력 조건을 명확히 구분하는 구현
